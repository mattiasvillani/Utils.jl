var documenterSearchIndex = {"docs":
[{"location":"LinAlgMisc/#Misc","page":"Linear algebra","title":"Misc","text":"","category":"section"},{"location":"LinAlgMisc/#Utils.invvech","page":"Linear algebra","title":"Utils.invvech","text":"invvech(v, p; fillupper = true)\n\nConstruct a symmetric matrix from its diagonal and lower diagonal elements. Fills by columns.\n\nv is a vector with the unique elements\np is the number of rows or columns of the returned symmetric matrix.\n\nSee also invvech_byrow(v, p; fillupper = true)\n\nExamples\n\njulia> invvech([11,21,31,22,32,33], 3)\n3×3 Matrix{Int64}:\n 11  21  31\n 21  22  32\n 31  32  33\n\n\n\n\n\n","category":"function"},{"location":"LinAlgMisc/#Utils.invvech_byrow","page":"Linear algebra","title":"Utils.invvech_byrow","text":"invvech_byrow(v, p; fillupper = true)\n\nConstruct a symmetric matrix from its diagonal and lower diagonal elements. Fills by row.\n\nv is a vector with the unique elements\np is the number of rows or columns of the returned symmetric matrix.\n\nSee also invvech(v, p; fillupper = true)\n\nExamples\n\njulia> invvech_byrow([11,21,22,31,32,33], 3)\n3×3 Matrix{Int64}:\n 11  21  31\n 21  22  32\n 31  32  33\n\n\n\n\n\n","category":"function"},{"location":"LinAlgMisc/#Utils.CovMatEquiCorr","page":"Linear algebra","title":"Utils.CovMatEquiCorr","text":"CovMatEquiCorr(σₓ, ρ, pBlock)\n\nSet up a covariance matrix with equi-correlation within blocks of variables\n\nσₓ is a p-vector with standard deviations \nρ[i] is the correlation within block i \npBlock[j] is the number of variables in block j\n\nExamples\n\njulia> σₓ = [1,2,3]; ρ = [0.5,0.8]; pBlock = [1,2];\njulia> CovMatEquiCorr(σₓ, ρ, pBlock)\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  4.0  4.8\n 0.0  4.8  9.0\n\n\n\n\n\n","category":"function"},{"location":"LinAlgMisc/#Utils.Cov2Corr","page":"Linear algebra","title":"Utils.Cov2Corr","text":"ρ, σ = Cov2Corr(Σ)\n\nCompute the correlation matrix ρ and vector standard deviations σ for the covariance matrix Σ.\n\nExamples\n\njulia> Σ = CovMatEquiCorr([1,2,3], [0.7], [3]) # Covariance matrix with all corr = 0.7\n3×3 Matrix{Float64}:\n 1.0  1.4  2.1\n 1.4  4.0  4.2\n 2.1  4.2  9.0\n\njulia> ρ, σ = Cov2Corr(Σ); ρ\n3×3 Matrix{Float64}:\n 1.0  0.7  0.7\n 0.7  1.0  0.7\n 0.7  0.7  1.0\n\n\n\n\n\n","category":"function"},{"location":"Distr/#Distributions","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"Distr/#Distributions.TDist","page":"Distributions","title":"Distributions.TDist","text":"TDist(μ, σ, ν)\n\nDefines the three parameter version of the Student-t distribution.\n\nThe distribution is parameterized so that the variance is σ²ν/(ν-2). The distribution is constructed by extending the standard student-t in Distributions.jl using the LocationScale construction in that same package. \n\nExamples\n\njulia> using Statistics: mean;\njulia> using Distributions: pdf;\njulia> dist = TDist(1, 2, 5)\njulia> mean(dist) \n1.0\njulia> pdf(dist, 1)\n0.18980334491124723\n\n\n\n\n\n","category":"type"},{"location":"Distr/#Utils.GaussianCopula","page":"Distributions","title":"Utils.GaussianCopula","text":"GaussianCopula(CorrMat, f)\n\nConstruct a Gaussian Copula with correlation matrix CorrMat and marginal distributions given by the elements in the vector of distributions in f. \n\nIf f is a singleton, then this distribution is used for all margins.\n\nExamples\n\njulia> using PDMats\njulia> f = [Normal(2, 3), Normal()]\njulia> CorrMat = PDMat([1 -0.8; -0.8 1])\njulia> GC = GaussianCopula(CorrMat, f)\n\n\n\n\n\n","category":"type"},{"location":"Distr/#Utils.PGDistOneParam","page":"Distributions","title":"Utils.PGDistOneParam","text":"PGDistOneParam(b, nterms)\n\nPolya-gamma distribution with one parameter and nterms in the tructation of the pdf. \n\nExamples\n\njulia> using Distributions: pdf;\njulia> d = PGDistOneParam(1, 10)\njulia> pdf(d, 1.1)\n\n\n\n\n\n","category":"type"},{"location":"Distr/#Utils.NormalInverseChisq","page":"Distributions","title":"Utils.NormalInverseChisq","text":"NormalInverseChisq(μ, σ2, κ, ν)\n\nA Normal-χ^-2 distribution is a conjugate prior for a Normal distribution with unknown mean and variance.  It has parameters:\n\nμ: expected mean\nσ2 > 0: expected variance\nκ ≥ 0: mean confidence\nν ≥ 0: variance confidence\n\nThe parameters have a natural interpretation when used as a prior for a Normal distribution with unknown mean and variance: μ and σ2 are the expected mean and variance, while κ and ν are the respective degrees of confidence (expressed in \"pseudocounts\").  When interpretable parameters are important, this makes it a slightly more convenient parametrization of the conjugate prior.\n\nEquivalent to a NormalInverseGamma distribution with parameters:\n\nm0 = μ\nv0 = 1/κ\nshape = ν/2\nscale = νσ2/2\n\nBased on Murphy \"Conjugate Bayesian analysis of the Gaussian distribution\".\n\n\n\n\n\n","category":"type"},{"location":"Distr/#Utils.ScaledInverseChiSq","page":"Distributions","title":"Utils.ScaledInverseChiSq","text":"ScaledInverseChiSq(ν,τ²)\n\nDefines the Scaled inverse Chi2 distribution with location ν and scale τ. \n\nThis is a convenience function that is just calling InverseGamma(ν/2,ν*τ²/2) \n\nExamples\n\njulia> using Statistics: mean;\njulia> using Distributions: pdf;\njulia> dist = ScaledInverseChiSq(10,3^2);\njulia> mean(dist)\n11.25\njulia> pdf(dist, 12)\n0.06055632954714239\n\n\n\n\n\n","category":"function"},{"location":"Distr/#Utils.SimDirProcess","page":"Distributions","title":"Utils.SimDirProcess","text":"SimDirProcess(P₀, α, ϵ)\n\nSimulates one realization from the Dirichlet Process DP(α⋅P₀) using the Stick-breaking construction.\n\nϵ>0 is the remaining stick length when the simulation terminates. \n\nExamples\n\njulia> θ, π = SimDirProcess(Normal(), 5, 0.001);\njulia> plot(-3:0.01:3, cdf.(Normal(), -3:0.01:3), label = \"base\", xlab = \"x\", \n    ylab = \"F(x)\", c = :red)\njulia> plot!(θ, cumsum(π), linetype = :steppost, xlab = \"θ\", \n    ylab = \"F(θ)\", label = \"realization\")\n\n\n\n\n\n","category":"function"},{"location":"Misc/#Misc","page":"Misc","title":"Misc","text":"","category":"section"},{"location":"Misc/#Utils.quantile_multidim","page":"Misc","title":"Utils.quantile_multidim","text":"quantile_multidim(A, p; dims, kwargs...)\n\nCompute quantiles along specified dimensions of multidimensional array A.\n\n\n\n\n\n","category":"function"},{"location":"Misc/#Utils.find_min_matrix","page":"Misc","title":"Utils.find_min_matrix","text":"find_min_matrix(matrix, k)\n\nReturns the Cartesian indices of the k:th smallest values in matrix. \n\nExamples\n\njulia> A = [10 8 12; 5 4 9; 3 6 2]\njulia> find_min_matrix(A, 3)\n\n\n\n\n\n","category":"function"},{"location":"Misc/#Utils.find_max_matrix","page":"Misc","title":"Utils.find_max_matrix","text":"find_max_matrix(matrix, k)\n\nReturns the Cartesian indices of the k:th largest values in matrix. \n\nExamples\n\njulia> A = [10 8 12; 5 4 9; 3 6 2]\njulia> find_max_matrix(A, 3)\n\n\n\n\n\n","category":"function"},{"location":"Misc/#Utils.ConstructOptimalSubplot","page":"Misc","title":"Utils.ConstructOptimalSubplot","text":"ConstructOptimalSubplot(NumberOfPlots)\n\nSilly function that returns the 'optimal' number of rows and columns for a subplot given the number of plots.\n\n\n\n\n\n","category":"function"},{"location":"Misc/#Utils.plot_braces!","page":"Misc","title":"Utils.plot_braces!","text":"plot_braces!(x, y, width, height, up = true, horizontal = true)\n\nPlots curly braces with tip at point (x,y) with braces total width of width and height. Accepts additional keywords arguments for plot styling. If up is true, the braces point upward. If horizontal = false, the braces are vertical.\n\nExamples\n\njulia> plot(-2π:0.01:2π, sin.(-2π:0.01:2π))\njulia> plot_braces!(π/2, 1, 2, 0.1; lw = 1, color = :black) \njulia> annotate!(π/2, 1.15, text(L\"f(1.57) = 1\", :black, :middle, 8))  \n\n\n\n\n\n","category":"function"},{"location":"PlotUtils/#Distributions","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"PlotUtils/#Utils.plotFcnGrid","page":"Distributions","title":"Utils.plotFcnGrid","text":"plotFcnGrid(f, xGrid, xNames, fcnArgs...;ylabel=\"\", title =\"\", levels = 10,fill=:viridis)\n\nPlotting a function of a 1D or 2D grid.\n\n\n\n\n\n","category":"function"},{"location":"PlotUtils/#Utils.plotClassifier2D","page":"Distributions","title":"Utils.plotClassifier2D","text":"plotClassifier2D(y, X, predictFunc; gridSize = [100,100], colors = missing, axisLabels = missing)\n\nPlots the decision boundaries of a classifier predictFunc() with two inputs\n\npredictFunc should take x1, x2 as inputs and returns a class in unique(y)\nclass labels can be Categorical or Int\n\n\n\n\n\n","category":"function"},{"location":"#Utils.jl","page":"Home","title":"Utils.jl","text":"","category":"section"},{"location":"#Purpose","page":"Home","title":"Purpose","text":"The Utils.jl package contains general utility functions.","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"Bayes/#Bayesian-tools","page":"Bayesian tools","title":"Bayesian tools","text":"","category":"section"},{"location":"Bayes/#Utils.HPDregions","page":"Bayesian tools","title":"Utils.HPDregions","text":"HPDregions(data::AbstractArray, coverage)\n\nCompute the highest posterior density (HPD) regions based on a kernel density estimate of the data. \n\ncoverage ∈ (0,1) is the probability mass to be included in the HPD region.\n\nExamples\n\njulia> hpdregion, actualCoverage = HPDregions(randn(100), 0.95)\n\n\n\n\n\nHPDregions(d::UnivariateDistribution, coverage)\n\nCompute the highest posterior density (HPD) regions for the distribution d. \n\ncoverage ∈ (0,1) is the probability mass to be included in the HPD region.\n\nExamples\n\njulia> hpdregion, actualCoverage = HPDregions(Normal(0,1), 0.95)\n\n\n\n\n\n","category":"function"},{"location":"Bayes/#Utils.finiteNewtonMH","page":"Bayesian tools","title":"Utils.finiteNewtonMH","text":"finiteNewtonMH(θₛ::Vector, ℓπ, ∇, H, nNewton, df, args...)\n\nFinite step Newton Metropolis-Hastings update a vector parameter\n\nθₛ is the current value of the parameter vector θ\nℓπ(θ, πargs...) is the log posterior function\n∇(θ, πargs...) is the gradient function (perhaps obtained by automatic differentiation)\nH(θ, πargs...) is the Hessian matrix function\nnNewton is the number of Newton steps\ndf is the degrees of freedom in the multivariate student-t proposal\nargs are the arguments (data etc) needed to compute the log posterior ℓπ\n\nSee also the method when θₛ is a scalar.\n\n\n\n\n\nfiniteNewtonMH(θₛ, ℓπ, ∇, H, nNewton, df, args...)\n\nFinite step Newton Metropolis-Hastings update for a scalar parameter\n\nθₛ is the current value of the parameter vector θ\nℓπ(θ, πargs...) is the log posterior function\n∇(θ, πargs...) is the gradient function (typically obtained by AutoDiff)\nH(θ, πargs...) is the Hessian matrix function\nnNewton is the number of Newton steps\ndf is the degrees of freedom in the multivariate student-t proposal\nargs are the arguments (data etc) needed to compute the log posterior ℓπ\n\nSee also the method when θₛ is a vector.\n\n\n\n\n\n","category":"function"}]
}
